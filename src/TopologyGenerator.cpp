
#include "TopologyGenerator.h"

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <iterator>
#include <fstream>
#include <map>
#include <algorithm>


#define PERCENTAGE_OF_NEIGHBORING_NODES_ 0.015
#define RANDOM_SEED_ 5

typedef std::map<int,int> IngresPairs;
 typedef std::multimap<std::pair<int, int>,int > myMap;


using std::chrono::system_clock;
using namespace std;



//Seed random number generator
std::mt19937 generator5(system_clock::to_time_t(system_clock::now()));

Brite::Brite(){}


// Generate topology with random number of nodes
Graph* Brite::GenerateTopology(const int AS,const int num_of_nodes)
{
	//std::uniform_real_distribution<double> Num_of_Nodes(0, RANDOM_SEED_);

	AS_ID=AS;
	NumberOfNodes= num_of_nodes;
	NumberofNeighboringNode=2;		//num_of_nodes * PERCENTAGE_OF_NEIGHBORING_NODES_ ;
    NodePlacement=1; 				//Random = 1, Heavy Tailed = 2
	BWDist=1;    					//Constant = 1, Uniform =2, HeavyTailed = 3, Exponential =4
	BWMin=10.0;
	BWMax=1024.0;
        
    std::cout<<"\n------------Brite Subprocess Called ! \nParameters:\n"
            "- NumberOfNodes :: "<<NumberOfNodes<< 
            "\n- NumberofNeighboringNode :: "<<NumberofNeighboringNode<<
            "\n- NodePlacement :: "<<NodePlacement<< "  ##Random = 1, Heavy Tailed = 2 "<<
            "\n- BWDist :: "<<BWDist<< "    ##Constant = 1, Uniform =2, HeavyTailed = 3, Exponential =4 "<<
            "\n------------\n" << std::endl;

	Prepare_Configuration();
	Run_Generator_Script();

	EndProduct = Populate_Topology_Result(string("../BRITE/outputfile.brite"));
  printf("BRITE Success.\n\n");    

	return EndProduct;
}


// Generate topology with random number of nodes
Graph* Brite::GenerateTopology(const int AS,const int Dist,const int Min,const int Max)
{
	std::uniform_real_distribution<double> Num_of_Nodes(0, RANDOM_SEED_);

	AS_ID=AS;
	NumberOfNodes= Num_of_Nodes(generator5);
	NumberofNeighboringNode=NumberOfNodes * int(PERCENTAGE_OF_NEIGHBORING_NODES_) ;
        
	BWDist=Dist;
	BWMin=Min;
	BWMax=Max;

	Prepare_Configuration();
	//Run_Generator_Script();
	//EndProduct = Populate_Topology_Result();
	return EndProduct;
}


void Brite::Prepare_Configuration()
{

  std::ofstream myfile;
  myfile.open ("../BRITE/MyConfig.conf");
  if (myfile.is_open())
     {
         std::string str= "#This config file was generated by the GUI.\n "
		"\n"
		"BriteConfig\n"
		"\n"
		"BeginModel\n"
			"\tName =  2		 #Router Barabasi=2, AS Barabasi =4\n"
			"\tN = " + std::to_string(NumberOfNodes) + "			 #Number of nodes in graph\n"
			"\tHS = 1000		 #Size of main plane (number of squares)\n"
			"\tLS = 100		 #Size of inner planes (number of squares)\n"
			"\tNodePlacement = 1	 #Random = 1, Heavy Tailed = 2\n"
			"\tm = "+std::to_string(NumberofNeighboringNode)+"			 #Number of neighboring node each new node connects to.\n"
			"\tBWDist = "+std::to_string(BWDist)+"		 #Constant = 1, Uniform =2, HeavyTailed = 3, Exponential =4\n"
			"\tBWMin = "+std::to_string(BWMin)+"\n"
			"\tBWMax = "+std::to_string(BWMax)+"\n"
		"EndModel\n"
		"\n"
		"\n"
		"\n"
		"BeginOutput 			#**Atleast one of these options should have value 1**\n"
			"\tBRITE = 1		#0 = Do not save as BRITE, 1 = save as BRITE.  \n"
			"\tOTTER = 0		#0 = Do not visualize with Otter, 1 = Visualize\n"
			"\tDML = 0			#1/0=enable/disable output to SSFNet's DML format \n"
			"\tNS = 0			#1/0=enable/disable output to NS-2\n"
			"\tJavasim = 0		#1/0=enable/disable output to Javasim\n"
		"EndOutput\n";
		
	myfile << str;
	myfile.close();
  }else{
	   std::cerr<<"Unable to open file myfile"<<std::endl;
          exit(1);
     }

}

void Brite::Run_Generator_Script()
{
	FILE *output;
	// brite executable, seed file and config file must be in same directory
  //output = popen ("./Brite MyConfig.conf outputfile seed_file", "w");
  output = popen("cd ../BRITE && java -Xmx6144M -classpath Java/:../:. Main.Brite  MyConfig.conf outputfile seed_file", "w");

  if (!output)
    fprintf (stderr,"incorrect parameters or too many files.\n");

  pclose(output); 
  printf("BRITE Success.\n\n");    
}


template <typename Container>
Container& split(Container& result,
  const typename Container::value_type& s,
  const typename Container::value_type& delimiters)
{
  result.clear();
  size_t current;
  size_t next = -1;
  do {
    current = next + 1;
    next = s.find_first_of( delimiters, current );
    result.push_back( s.substr( current, next - current ) );
  } while (next != Container::value_type::npos);
  return result;
}




Graph* Brite::Populate_Topology_Result(std::string fileName)
{
	int num_of_vertex,num_of_edges;
	std::vector <int> nodes;
	myMap edges; 

    const std::string delimiter{"\t"};
    std::vector<std::vector<std::string> > v;
    // fetch the file into v
    std::string line;
    std::vector<std::string> fields;

    for( std::ifstream in(fileName.c_str()); std::getline(in, line); ) 
    {
    	//std::cout << line << std::endl;
        v.push_back(split(fields, line, delimiter));
    }
    // now print the results
	
	const auto &first = v[0];
	const auto &second = v[1];
	num_of_vertex=stoi(first[1]);
	num_of_edges=stoi(second[1]);
	
	v.erase (v.begin());
	v.erase (v.begin());

	cout<<"Number of Vertices: " << num_of_vertex << endl;
	cout<<"Number of Edges:    " << num_of_edges << endl;
	
	// add all the vertices to the vector
	for(int i = 0; i < num_of_vertex; i++)
	{
		nodes.push_back(i);
	}

	// add all the edges to the vector
    for (const auto &i : v) 
    	{		
			edges.insert(std::make_pair(std::make_pair(stoi(i[1]),stoi(i[2])),1));
		}

	v.clear();

	Graph * n1= new Graph(num_of_vertex,num_of_edges, nodes,edges);
	return n1 ;
}